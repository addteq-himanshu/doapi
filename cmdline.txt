[Rethink this:] There is no filtering of result lists by region, image, etc.;
the only query filters available are those directly supported by the API.  For
everything else, use `jq`.

There are no options for controlling pagination.  The only instance where
pagination should have an effect on the outcome is for raw requests, and for
those the user can just append `?per_page=` to the path.

Options common to all commands:
    --api-key key
    --api-key-file file
    --timeout int
    --endpoint URL

Options common to all actions (including creating droplets):
    --wait
    --wait-time seconds
    --wait-interval seconds

Options common to all operations on droplets, SSH keys, & images:
    --unique  # enforces uniqueness among names (settable via config file?)
	      # With --unique, images cannot be given names that are the same
	      # as a slug (and SSH keys can't be given names that could be
	      # fingerprints?)
    --ignore ?  # with `--unique`, don't error on nonunique names

Better idea: `--unique` is always on by default; to create an object with a
duplicate name, a `--force` option is required.  Using a non-unique name in a
command raises an error unless some option is specified to make the name expand
to all matching objects.

When getting lists of objects for multiple items (e.g., getting the snapshots
for a list of more than one droplet), the output is a list of lists of objects.

API key sources, in order of precedence:
 - API key or keyfile specified on the command-line (mutually exclusive)
 - DO_API_KEY environment variable
 - DO_API_TOKEN environment variable
 - ~/.doapi file [Rethink name]


<droplet> := ID or name
<sshkey>  := ID, fingerprint, or name
	     # When creating a droplet, it should be possible to specify files
	     # as SSH keys, causing them to be automatically registered with DO
<image>   := ID, slug, or name (slugs take precedence)
<action>  := ID


doapi-droplet
	[show [<droplet> ...]]
	new
	    -i|--image <image>
	    -s|--size <size>
	    -r|--region <region>
	    [--json <file>]
	     # A JSON array (or an object, which is treated as an array
	     # of one) is read from <file> (which may be '-'), the
	     # -i/-s/-r values are applied to those objects that are
	     # missing them, and the droplets are created from the
	     # objects.  When --json is given, no `name` arguments
	     # should be given.
	    <wait options>
	    [--user-data data]
	    # ipv6, backups, etc.
	    # Add an option (--ignore?) for not creating any droplets that
	    # already exist but printing out the pre-existing droplets anyway
	    <name> ...
	delete <droplet> ...
	wait [--status=STATUS] <wait options> <droplet> ...
	    # No status â†’ wait for latest action to complete
	    # Error out (unless --force'd?) if an unknown value is used
	    # for "status"
	    # Add waiting for specific actions?
	<action name> <wait options> <droplet> ...
	    # Arguments to actions are specified with `--name=value`
	upgrades [--droplets]
	    # --droplets: return the droplets that will be upgraded instead
	# raw action
	# getting actions
	# getting last action
	snapshots <droplet> ...
	backups <droplet> ...
	kernels <droplet> ...
	neighbors [<droplet> ...]

doapi-request  # raw request
    [-X <method>]
    [-d/--data <string|@file>]  # as in curl
    [-D/--dump-header <file>]   # as in curl
    [--paginate <key>]
    <URL>|<path>

doapi-sshkey
	[show [<sshkey> ...]]
	new <name> [<file>; default: stdin]
	    # Add an option for only creating if the public key isn't
	    # already present (and another for returning the
	    # pre-existing key in that case?)
	    # Add an option for passing the entire key as a string
	delete <sshkey> ...
	update <sshkey> <new name>

doapi-image
	[show [--type TYPE|--distribution|--application] [--private] ...]
	update <image> <new name>
	delete <image> ...
	transfer <image> <region>
	transfer -r|--region <region> <image> ...
	convert <image> ...
	# raw action
	# getting actions
	# getting last action
	# waiting for last action(s) (or specific actions?)

doapi-action
	show  # Add --latest option?  --in-progress?
	latest  # Merge into `show`?
	wait {--latest/--all | <action> ...}
	resource <action> ...  # fetch resource
	# duplicates of the commands for manipulating droplet & image
	#   actions???

	# In theory, it might be possible to fetch all in-progress actions
	# efficiently by merely requesting the first page of actions for each
	# droplet and each private image.

doapi-domain
	[show [name ...]]
	new <name> <ip address>
	delete <name> ...

	# Rethink most of this:
	record --domain=DOMAIN
		[show [id|??? ...]]
		new type name data [priority] [port] [weight]
		update id|??? [anything]
		delete id|???
		# Add a "set" command that replaces all pre-existing records
		# with a given name with a single record?

doapi-regions
doapi-sizes
doapi-account
