Options common to all commands:
    --api-key key
    --api-key-file file
    --timeout int
    --endpoint URL

Options common to all actions (including creating droplets):
    --wait
    --wait-time seconds
    --wait-interval seconds

API key sources, in order of precedence:
 - API key or keyfile specified on the command-line (mutually exclusive)
 - DO_API_KEY environment variable
 - DO_API_TOKEN environment variable
 - ~/.doapi file [Rethink name]


<droplet> := ID or name
<sshkey>  := ID, fingerprint, or name
	     # When creating a droplet, it should be possible to specify files
	     # as SSH keys, causing them to be automatically registered with DO
<image>   := ID, slug, or name (slugs take precedence)
<action>  := ID


doapi-droplet
	[show [<droplet> ...]]
	new
	    -i|--image <image>
	    -s|--size <size>
	    -r|--region <region>
	    [--json <file>]
	     # A JSON array (or an object, which is treated as an array
	     # of one) is read from <file> (which may be '-'), the
	     # -i/-s/-r values are applied to those objects that are
	     # missing them, and the droplets are created from the
	     # objects.  When --json is given, no `name` arguments
	     # should be given.
	    <wait options>
	    [--user-data data]
	    # ipv6, backups, etc.
	    <name> ...
	delete <droplet> ...
	wait [--status=STATUS] <wait options> <droplet> ...
	    # No status â†’ wait for latest action to complete
	    # Error out (unless --force'd?) if an unknown value is used for
	    # "status"
	    # Add waiting for specific actions?
	<action name> <wait options> <droplet> ...
	upgrades [--droplets]
	    # --droplets: return the droplets that will be upgraded instead
	# raw action
	# getting actions
	# getting last action
	snapshots <droplet> ...
	backups <droplet> ...
	kernels <droplet> ...
	neighbors [<droplet> ...]

doapi-request  # raw request
    [-X <method>]
    [-d/--data <string|@file>]  # as in curl
    [-D/--dump-header <file>]   # as in curl
    [--paginate <key>]
    <URL>|<path>

doapi-sshkey
	[show [<sshkey> ...]]
	new <name> [<file>; default: stdin]
	delete <sshkey> ...
	update <sshkey> <new name>

doapi-image
	[show [--type TYPE|--distribution|--application] [--private] ...]
	update <image> <new name>
	delete <image> ...
	transfer <image> <region>
	transfer -r|--region <region> <image> ...
	convert <image> ...
	# raw action
	# getting actions
	# getting last action
	# waiting for last action(s) (or specific actions?)

doapi-action
	show  # Add --latest option?  --in-progress?
	latest  # Merge into `show`?
	wait {--latest/--all | <action> ...}
	resource <action> ...  # fetch resource

	# In theory, it might be possible to fetch all in-progress actions
	# efficiently by merely requesting the first page of actions for each
	# droplet and each private image.

doapi-domain
	[show [<name> ...]]
	new <name> <ip address>
	delete <name> ...

	### Rethink how the domain is specified:
	record --domain=DOMAIN
		[show [<id> ...]]
		### Showing by type and/or name
		new <type> <name> <data> [<priority> [<port> [<weight>]]]
		set <type> <name> <data> [<priority> [<port> [<weight>]]]
		# `set` is like `new` but deletes any & all pre-existing
		# records with the same type & name.
		update [--type TYPE]
		       [--name NAME]
		       [--data DATA]
		       [--priority PRIORITY]
		       [--port PORT]
		       [--weight WEIGHT]
		       <id>
		delete <id> ...
		### Deletion by type and/or name?

doapi-regions
doapi-sizes
doapi-account
